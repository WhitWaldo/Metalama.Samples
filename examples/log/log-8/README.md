---
uid: sample-log-8
level: 300
---

# Logging Example: Avoiding infinite recursion

[!metalama-project-buttons .]

When the logging logic of a method calls the logging logic of another method, an infinite recursion can happen.

Avoiding infinite recursion in logging is crucial for maintaining application stability, performance, and log readability. Infinite recursion can lead to stack overflow exceptions, causing crashes or unintended side effects. It also consumes system resources, negatively impacting performance and potentially rendering the application, and any other application on the same device, unresponsive. Furthermore, excessive log entries generated by recursion complicate log analysis, increase storage requirements, and hinder the debugging process by making it difficult to locate the actual source of the problem amidst repeated log entries.

So, infinite recursions in logging must be avoided at any cost.

A first line of defense is to avoid logging the `ToString` method. However, even a non-logged `ToString` method could access logged properties or methods, and indirectly cause an infinite recursion. The most reliable approach is to add the following code in the logging pattern:

```cs
using ( var guard = LoggingRecursionGuard.Begin() )
{
  if ( guard.CanLog )
  {
    this._logger.LogTrace( message );
  }
}
```

Let's update our last example with this new pattern:

[!metalama-compare LoginService.cs]

## Infrastructure code

`LoggingRecursionGuard` uses a thread-static field indicating whether we are currently logging:

[!metalama-file LoggingRecursionGuard.cs]

## Aspect code

The `LogAttribute` code is now the following:

[!metalama-file LogAttribute.cs]
