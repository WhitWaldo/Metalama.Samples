---
uid: sample-dirty-3
---

# Change Tracking example, step 3: integrating with INotifyPropertyChanged

[!metalama-project-buttons .]

At this point, we have a `TrackChanges` aspect that properly implements the <xref:System.ComponentModel.IChangeTracking> interface. It supports hand-written base implementations and reports errors if the pattern contract is not respected. However, we have built this aspect is pure isolation. In practice, the `TrackChanges` aspect will have to interact with the `NotifyPropertyChanged` pattern. That is, when the <xref:System.ComponentModel.IChangeTracking.IsChanged> property changes, the <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged> event must be raised.

It is important to understand that the two concepts that are interacting with each other are not aspects or interfaces but _patterns_. Aspects, by definition, are executable artifacts that automate the implementation and verification patterns, but patterns can also be implemented manually. Patterns define extension points. For instance, <xref:System.ComponentModel.INotifyPropertyChanged> is an interface, and this interface does not include the `OnPropertyChanged` method. This method is part of the _pattern_. Patterns are essentially _conventions_, so a different pattern of implementation can rely on a different triggering mechanism than the `OnPropertyChanged` method.

Therefore, when you design an aspect, you should first reason about the _pattern_, think about how the patterns combine, and how they work with inherited classes or with parent-child relationships.

For this example, we decide (this is a design pattern _decision_) to call the `OnChange` method from the `OnPropertyChanged` method. Why? There are two reasons for this. First, the setters of all mutable properties are already supposed to call the `OnPropertyChanged` method, so it would be a double pain to have to add a new call to `OnChange` everywhere. This argument is valid if we are implementing the pattern by hand, but what if we are using an aspect? Here comes the second reason: when two aspects are added to the same property, the code generated by Metalama is much less readable. 

Let's see this pattern in action:

[!metalama-files Comment.cs ModeratedComment.cs]


## Aspect implementation

The new aspect implementation is the following:

[!metalama-file TrackChangesAttribute.cs]

Notice the new `GetOnPropertyChangedMethod` method. It looks for the `OnPropertyChanged` method in the <xref:Metalama.Framework.Code.INamedType.AllMethods> collection, which contains methods defined by the current type as well as the ones from the base class, if they are accessible. Therefore, `GetOnPropertyChangedMethod` may return an <xref:Metalama.Framework.Code.IMethod> from the current type, from the base class, or `null`.

[!metalama-file TrackChangesAttribute.cs member="TrackChangesAttribute.GetOnPropertyChangedMethod"]

We call `GetOnPropertyChangedMethod` from `BuildAspect`. 

If we did not find _any_ `OnPropertyChanged`, we have to override all fields and automatic properties ourselves:

[!metalama-file TrackChangesAttribute.cs from="NoOnPropertyChanged:Start" to="NoOnPropertyChanged:End"]

However, if the closest `OnPropertyChanged` method is in the base type, the logic is more complex:

[!metalama-file TrackChangesAttribute.cs from="NoOnPropertyChanged:Start" to="NoOnPropertyChanged:End"]

If the closest `OnPropertyChanged` is in the current type, we override it:

[!metalama-file TrackChangesAttribute.cs from="OnPropertyChangedInBaseType:Start" to="OnPropertyChangedInBaseType:End"]

If _both_ the `OnPropertyChanged` method and the `ISwitchableChangeTracking` interface were defined in a base type, then we do not have do hook `OnPropertyChanged` because we already did it in the base type. In this case, we rely on the fact that the outcome of the <xref:Metalama.Framework.Advising.IAdviceFactory.ImplementInterface*> method was `Ignored`.

However, if the base type defines a `OnPropertyChanged` method but _no_ `ISwitchableChangeTracking` interface, we need to override the `OnPropertyChanged` method. It's only possible if the base method is `virtual`. Otherwise, we report an error. To override a method of the base class, we need to use <xref:Metalama.Framework.Advising.IAdviceFactory.IntroduceMethod*>  instead of <xref:Metalama.Framework.Advising.IAdviceFactory.Override*>.


Finally, we also need to change the implementations of `IsTrackingChanges` and `OnChange` to call `OnPropertyChanged`. Let's see for instance `OnChange`:

[!metalama-file TrackChangesAttribute.cs member="TrackChangesAttribute.OnChange"]

If the `OnPropertyChanged` method is present, we invoke it using the <xref:Metalama.Framework.Code.Invokers.IMethodInvoker.Invoke*> method. Note that <xref:Metalama.Framework.Code.Invokers.IMethodInvoker.Invoke*> does not really invoke the method, because the code runs at compile time. What it actually does is to _generate the code_ that will invoke the method at run time. Note also that we cannot use the conditional `?.` operator in this case. We must use an `if` statement to check if the `OnPropertyChanged` method is present.

