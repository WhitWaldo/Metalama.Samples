---
uid: sample-notifypropertychanged
---

# Example: INotifyPropertyChanged

[!metalama-project-buttons .]

<xref:System.ComponentModel.INotifyPropertyChanged> is an essential interface in the .NET Framework, especially for applications using data binding or the MVVM pattern. It enables automatic UI updates when properties in the data model change by raising the <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged> event. Implementing this interface in data models increases their reusability across different views. The <xref:System.ComponentModel.INotifyPropertyChanged> is supported by most .NET UI frameworks including WPF, WinForms, WinUI and Blazor.

However, implementing <xref:System.ComponentModel.INotifyPropertyChanged> often involves a significant amount of boilerplate code, making it cumbersome and time-consuming to maintain. Each property requires additional code to raise the <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged> event not only for itself, but for all dependent properties, which can quickly become unwieldy in large data models. Fortunately, you can use an aspect to inject the necessary code automatically, reducing the manual effort required to implement the interface. With Metalama, you can maintain cleaner and more manageable code, focusing on the core logic of their applications while still benefiting from the responsive UI updates and improved data binding that <xref:System.ComponentModel.INotifyPropertyChanged> provides.

In the following example, we show how source code is transformed by the aspect. The code generated by Metalama is displayed in green.

[!metalama-compare MovingVertex.cs]

## Implementation

In this example, we will explain the simplest possible implementation of the `NotifyPropertyChanged` aspect. As with any aspect, before starting to write code, it is good to take a pause and think a few minutes about the design. Here is how we want this aspect to work:

1. The aspect will add the <xref:System.ComponentModel.INotifyPropertyChanged> interface to the target type unless that type already implements this interface.
2. The aspect will add the `OnPropertyChanged` method unless the target type already contains it. This method will call the <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged> event.
3. The aspect will override the setter of all properties and call `OnPropertyChanged`.
4. The aspect will automatically propagate from the base class to derived classes.

Note that this is a basic implementation. Specifically, it does not take into account _dependent properties_ i.e. properties that depend on other properties.

Here is the code of this aspect.

[!metalama-file NotifyPropertyChangedAttribute.cs]

As you can see, the `NotifyPropertyChangedAttribute` class inherits the <xref:Metalama.Framework.Aspects.TypeAspect> because this is an aspect that applies to types. 

The <xref:Metalama.Framework.Aspects.InheritableAttribute?text=[Inheritable]> custom attribute on the top of the class means that the aspect must be inherited from the base class to derived classes. For details, see <xref:aspect-inheritance>.

Let's look in detail to the implementation of the `BuildAspect` method.

[!metalama-file NotifyPropertyChangedAttribute.cs member="NotifyPropertyChangedAttribute.BuildAspect"]

The `BuildAspect` method first calls <xref:Metalama.Framework.Advising.IAdviceFactory.ImplementInterface*> to add the <xref:System.ComponentModel.INotifyPropertyChanged> interface to the target type. The `whenExists` parameter is set to `Ignore`, which means that this call will just be ignored if the target type or a base type already implements the interface. The <xref:Metalama.Framework.Advising.IAdviceFactory.ImplementInterface*> method requires the interface members to be implemented by the aspect class and to be annotated with the <xref:Metalama.Framework.Aspects.InterfaceMemberAttribute?text=[InterfaceMember]> custom attribute. Here, our only member is the `PropertyChanged` event:

[!metalama-file NotifyPropertyChangedAttribute.cs member="NotifyPropertyChangedAttribute.PropertyChanged"]

To read more about this, see <xref: implementing-interfaces>.

Note that the `OnPropertyChanged` method is not a part of the <xref:System.ComponentModel.INotifyPropertyChanged> interface, so we do not introduce it using the <xref:Metalama.Framework.Aspects.InterfaceMemberAttribute?text=[InterfaceMember]> custom attribute but using <xref:Metalama.Framework.Aspects.IntroduceAttribute?text=[Introduce]>. Again, we specify the <xref:Metalama.Framework.Aspects.IntroduceAttribute.WhenExists> property to `Ignore`, so we skip this step if the target type already contains this method.

[!metalama-file NotifyPropertyChangedAttribute.cs member="NotifyPropertyChangedAttribute.OnPropertyChanged"]

`OnPropertyChanged` invokes the `PropertyChanged` event. Note that the expression `meta.This` is translated into simply `this` by Metalama. For more detail about adding methods, see <xref:introducing-members>.

Let's go back to the `BuildAspect` method. The second thing it does it to iterate through all properties that have a setter. It calls the <xref:Metalama.Framework.Advising.IAdviceFactory.OverrideAccessors*> and supplies `OverridePropertySetter` as a template for the new property setter. For details, see <xref:overriding-fields-or-properties>.

Let's look at this template:

[!metalama-file NotifyPropertyChangedAttribute.cs member="NotifyPropertyChangedAttribute.OverridePropertySetter"]

The expression `meta.Target.Property.Value` gives us the current value of the property. When Metalama applies the aspect to an automatic property, it turns it into a field-backed property, and this expression resolves to the backing field.

`meta.Proceed()` invokes the original implementation of the property. In the case of an automatic property, this means that the backing field is set to the `value` parameter.

Finally, the template calls the `OnPropertyChanged` method. `meta.Target.Property.Name` translates to the name of the current property.

## Limitations

This implementation has some important limitations and it's good to be aware of them.

* Dependent properties are silently ignored. For instance, in the following code, no notification would be raised for the `FullName` property:

    ```csharp
    class Person 
    {
        public string FirstName { get; set; }
        public string LastName { get; set; }

        // Notification never raised!
        public string FullName => $"{FirstName} {LastName}"
    }
    ```

    Currently Metalama does not allow you to analyze dependent properties. We will be working on this in a next version.

* The `PropertyChanged` event may be raised when class invariants are invalid. Consider for instance the following code:

    ```csharp
    class InvoiceLine
    {
        public decimal UnitPrice {get; private set; }
        public decimal Units {get; private set; }
        public decimal TotalPrice { get; private set; }

        public void Update( decimal unitPrice, decimal totalPrice )
        {
            this.UnitPrice = unitPrice;
            // PropertyChanged raised with broken invariants.
            this.Units = units;
            // PropertyChanged raised with broken invariants.
            this.TotalPrice = unitPrice * units;
        }
    }

    ```

    This class has an invariant `TotalPrice = UnitPrice * Units`. However, the `PropertyChanged` events will be raised in the middle of the `Update` class, when class invariants are invalid. A proper implementation would buffer the events and raise them at the end of the `Update` method, when all invariants are valid.

    Contrarily to the first limitation, it is possible to address this one.

> [!div class="see-also"]
> <xref:aspect-inheritance>
> <xref:implementing-interfaces>
> <xref:overriding-fields-or-properties>
> <xref:introducing-members>