---
uid: sample-dirty-3
---

# Change Tracking example, step 3: integrating with INotifyPropertyChanged

[!metalama-project-buttons .]

At this point, we have a `TrackChanges` aspect that properly implements the <xref:System.ComponentModel.IChangeTracking> interface. It supports hand-written base implementations and reports errors if the pattern contract is not respected. However, we have built this aspect is pure isolation. In practice, the `TrackChanges` aspect will have to interact with the `NotifyPropertyChanged` pattern. That is, when the <xref:System.ComponentModel.IChangeTracking.IsChanged> property changes, the <xref:System.ComponentModel.INotifyPropertyChanged.PropertyChanged> event must be raised.

It is important to understand that the two concepts that are interacting with each other are not aspects or interfaces with _patterns_. Aspects are things that automate the implementation and verification patterns, but patterns can also be implemented manually. Patterns define extension points. For instance, <xref:System.ComponentModel.INotifyPropertyChanged> is an interface, and this interface does not include the `OnPropertyChanged` method. This method is part of the  `NotifyPropertyChanged` _pattern_. Patterns are essentially _conventions_, so a different pattern of implementation can rely on a different triggering mechanism than the `OnPropertyChanged` method.

Therefore, when you design an aspect, you should first reason about the _pattern_, think about how the patterns combine, and how they work with inherited classes or with parent-child relationships.

For this example, we decide (this is a design pattern decision) to call the `OnChange` method from the `OnPropertyChanged` method. Why? There are two reasons for this. First, the setters of all mutable properties are already supposed to call the `OnPropertyChanged` method, so it would be a double pain to have to add a new call to `OnChange` everywhere. This argument is valid if we are implementing the pattern by hand, but what if we are using an aspect? Here comes the second reason: when two aspects are added to the same property, the code generated by Metalama is much less readable. 

Let's see this pattern in action:

[!metalama-files Comment.cs ModeratedComment.cs]


## Aspect implementation

The new aspect implementation is the following:

[!metalama-file TrackChangesAttribute.cs]

Notice the new `GetOnPropertyChangedMethod` method. It looks for the `OnPropertyChanged` method.

We call `GetOnPropertyChangedMethod` from `BuildAspect`. If the type has an `OnPropertyChanged` method, we do _not_ override the properties.

We then use this method in the implementations of `IsTrackingChanges` and `OnChange`. Let's see for instance `OnChange`:

[!metalama-file TrackChangesAttribute.cs member="TrackChangesAttribute.OnChange"]

If the OnPropertyChanged` method is present, we invoke it using the <xref:Metalama.Framework.Code.Invokers.IMethodInvoker.Invoke*> method. Note that <xref:Metalama.Framework.Code.Invokers.IMethodInvoker.Invoke*> does not really invoke the method, because the code runs at compile time. What it actually does is to _generate the code_ that will invoke the method at run time.

